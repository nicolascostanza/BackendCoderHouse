CLASE 04:
    * setTimeout(): tiene 2 parametros obligados, el primero es un callback(funcion pasada por parametro) y el segundo la cantidad de tiempo a esperar. Ademas seguidos a estos dos podes pasarle mas parametros q son los q va a recibir el callback por parametro. Este metodo ejecuta SOLO UNA VEZ la funcion que recibe en el primer parametro
    * setInterval(): lo mismo q setTimeout pero ejecuta varias veces el CB, cada vez q pase el contador de timer pasado en el segundo lugar. Esto pasa hasta q se llama a clearInterval() o q se cierre la ventana
    * El modulo File System (fs) solo esta presente en nodejs, no existe en el navegador
    * const fs = require("fs")
    * Tiene opciones para manejar archivos sincrona y asincronamente. Para usar tus estos metodos, le pasamos primero el path y segundo el encoding('utf-8')
    * Siempre mejor usar rutas relativas con el ./
    * readFileSync, es bloqueante, espera a terminarla, la q no tiene sync sigue con la ejecucion
CLASE 05:
    * npm init en consola para crear el package-json, donde instalar todas las librerias necesarias
    * npm install solo te instala en dependencias generales, si le pones npm install --save--dev {nombre de la libreria} o npm install -D te la instala en dev dependencies
    * cors libreria, nos permite aceptar request en el server desde cualquier punto del planeta, aunque sea raro
    * en el package-json si tenemos antes de la version de la libreria un:
        1) ~ significa q cuando cuando hagamos npm install solo se actualizara a las veriones con un cambio de patch example: '1.13.14', en este caso el 14
        2) ^ significa q actualiza los patch y los cambios menores, example: 1.13.14 ---> actualizaria en el .13 y .14
        3) * significa q actualiza todoo, los patchs, los minor releases o major releases
        4) si no hay ninguna de las 3 de arriba, se acepta solo la version puesta
    * para correr el archivo vamos a la parte de scripts en package-json y ponemos "start": "node index.js" ---> luego en consola se corre con node start
VER CORS EN MOZILLA: https://developer.mozilla.org/es/docs/Web/HTTP/CORS
CLASE 06:
    * http: hiper text transfer protocol
    * el modulo http:
        es nativo
        trabaja con el protocolo HTTP
        para usarlo require('http')
        para crear un servidor hacemos: http.createServer()
        para linkear un puerto al codigo hhtp.server.listen(3000, ()=> {}), asi ? ver bien
    * payload ---> informacion q se reciba o se envie en una API
    * para hacer import .... from ... en vez de const ... = require('...') tenemos q ir al package.json y ponerle antes de los script "type": "module",
    * la diferencia entre res.send() y res.end() es q res.end() da como finalizada la ejecucion, osea ya no hace mas nada. Ademas no pueden enviar todos los tipos de datos. Tambien existe el res.render() q manda un html a renderizar
    * para iniciar con exprees en ves de html (ademas hay q instalarlo, pq no es un modulo nativo):
        1) let express = require('express'); o import express from 'express'
        2) let app = express()
    * exiten dos tipos de API ---> tipo rest, q trabaja con endpoints, y graphQl que es un solo endpoint q devuelve una red con todo
    * https://glitch.com/ sirve para deployar un servidor rudimentario
CLASE 07:
    * una api restful tiene q usar base de datos o archivos para q sea persistente pq se debe resetear todo al recargar
    * status code:
        1xx ---> informativos
        2xx ---> exito
        3xx ---> redireccion
        4xx ---> cliente error
        5xx ---> server error
    * swagger es una pagina para documentar y hacer peticiones
    * rest indica ademas los formatos de transferencia de archivos. Los mas comunes. XML y JSON
    * API REST:
        1) no tiene interfaz grafica
        2) utiliza protocolo http
        3) arquitectura cliente servidor: cada mensaje http contiene toda la info necesaria para hacer la peticion. Esto hace que cliente y servidor esten debilmente acoplados (importante)
        4) cacheable: para almacenar informacion en una memoria y asi no tenes q consultar todo el tiempo. Esto hace q sea mas performante
        5) operaciones comunes (operaciones crud)
        6) interfaz uniforme
        7) utilizacion de hipermedios
    * una app de chatting no se hace con api rest. Se hace con otra api de comunicacion en tiempo real, q se hacen con otro protocolo. Usan socket io.
    * capas en arquitectura de api restful: routing, capa de negocios, orm (capa de conexion con la base de datos)
    * para pasar parametros por la url tenes params, y query params:
        query params: empiezan en el momento en el q la url tiene '?' y siguen con "clave=valor", si se quieren agregar mas ponemos un "&"
        params: se les pasa desp de un "/:params"
    * lazy loading, sirve para la paginacion.
    * para q el server con express pueda interpretar de forma automaticva los mensajes de tipo JSON en formato urlencoded al recibirlos, debemos agregarle lo siguiente al crearlo:
        1) app.use(express.json())
        2) app.use(express.urlencoded({extended: true}))
    * para aplicar un middleware a nivel de aplicacion ponemos app.use()
CLASE 08:
    * para el manejo de rutas express tiene una clase llamada Router. Sirve para modularizar la api rest
    * para usarlo ponemos --->
    const express = require('express')
    const { Router } = express
    const app = express()
    const router = Router()
    * las clases siempre se llaman con mayusculas
    * los middleware tienen el parametro next, donde lo usamos poniendo next() y hace q se ejecute siemrpe la siguiente funcion en la lista
    *middlewares tipos:
        ** a nivel de aplicacion
        ** a nivel de router
        ** manejo de errores
        ** incorporados
        ** de terceros
    * module exports para exportar en el back siempre
    * cuando usas import es pq te queres traer todo sino en require para traerte solo una cosa

CLASE 09:
    * handlebars es un lenguaje de plantillas
    * tienen un template, una data base y con eso genera un template

clase 10:
    * pug y ej son motores de templates como handlebars
    * pug esta diseñado para hacer cosas mas pequeñas. Funciona como python mediante tabs e identaciones. Se le pasan las vistas y el motor para setearlo
    * la extension del template es .pug
    * en el endpoint ponemos res.render('la vista', {un objeto con los datos q necesita el template para pintarlo})
    * seteo:
        app.set('views', './views'); el segundo parametro es el path raiz donde estan los archivos de las vistas
        app.set('view engine', 'pug');
    * para las props en pug se hace div() y entre los parentesis le pones lo q le queres dar
    * la etiqueta meter de html es una barra con min max y value para mostrrar
    * ejs es un motor de plantillas ---> npm install ejs
    *para seteo:
        app.set('view engine', 'ejs')
        el res.render busca dentro de la carpeta views. Osea q esto lo hace por defecto
    * sintaxis:
        <%= incrusta en plantilla el valor tal cual esta
        <%- incrusta en la plantilla el valor renderizado como html
        <% admite js
    * poniendo <%- inclue('./partials/header.ejs')-%> incluimos los partials q son como las partes q podemos reutilizar en los templates
Clase 11:
    * Websocket es un protocolo de red basado en TCP que establece cómo deben intercambiarse datos entre redes.
    * Es un protocolo fiable y eficiente, utilizado por prácticamente todos los clientes.
    * El protocolo TCP establece conexiones entre dos puntos finales de comunicación, llamados sockets.
    * De esta manera, el intercambio de datos puede producirse en las dos direcciones
    * websockets tiene conexiones bidireccionales, tenes acceso a los datos de forma rapida y permite una comunicacion directa y en tiempo real
    * handshake ?? (es la conexion)
    * Para iniciar el intercambio con Websocket el cliente envía una solicitud, al igual que en el clásico HTTP. Sin embargo, la conexión se establece mediante TCP y permanece abierta tras el handshake entre el cliente y el servidor.
    * El nuevo esquema URL de Websocket para las páginas web mostradas se define con el prefijo ws en lugar de http. El prefijo que corresponde a una conexión segura es wss, de forma análoga a https.
    * web sockets es un protocolo de comunicacion
    * Socket.IO es una biblioteca de JavaScript para aplicaciones web en tiempo real. Permite la comunicación bidireccional en tiempo real entre servidores y clientes web.
    * Tiene dos partes:
        - Una biblioteca del lado del cliente que se ejecuta en el navegador.
        - Una biblioteca del lado del servidor para Node.js.
    * Ambos componentes tienen una API casi idéntica. Al igual que Node.js, está impulsado por eventos.
    * caracteristicas de socket.io:
        - Fiabilidad: Las conexiones se establecen incluso en presencia de:
            proxies y balanceadores de carga.
            firewall personal y software antivirus.
        - Soporte de reconexión automática: A menos que se le indique lo contrario, un cliente desconectado intentará siempre volver a conectarse, hasta que el servidor vuelva a estar disponible.
        - Detección de desconexión: Se implementa un mecanismo de heartbeat, lo que permite que tanto el servidor como el cliente sepan cuando el otro ya no responde.
        - Soporte binario:  Se puede emitir cualquier estructura de datos serializable, que incluye:
            - ArrayBuffer y Blob en el navegador
            - ArrayBuffer y Buffer en Node.js
    * Utilizando el método io.sockets.emit enviamos un mensaje global a todos los clientes conectados al canal de Websocket
Clase 12:
    * io.on('connection', function(socket) {
        console.log('Un cliente se ha conectado');
        });
    * io.on('connection'. funcion) indica cuando alguien se conecta al servidor
    * con io.sockets.emit, que notificará a todos los sockets conectados.





