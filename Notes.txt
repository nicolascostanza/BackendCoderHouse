CLASE 04:
    * setTimeout(): tiene 2 parametros obligados, el primero es un callback(funcion pasada por parametro) y el segundo la cantidad de tiempo a esperar. Ademas seguidos a estos dos podes pasarle mas parametros q son los q va a recibir el callback por parametro. Este metodo ejecuta SOLO UNA VEZ la funcion que recibe en el primer parametro
    * setInterval(): lo mismo q setTimeout pero ejecuta varias veces el CB, cada vez q pase el contador de timer pasado en el segundo lugar. Esto pasa hasta q se llama a clearInterval() o q se cierre la ventana
    * El modulo File System (fs) solo esta presente en nodejs, no existe en el navegador
    * const fs = require("fs")
    * Tiene opciones para manejar archivos sincrona y asincronamente. Para usar tus estos metodos, le pasamos primero el path y segundo el encoding('utf-8')
    * Siempre mejor usar rutas relativas con el ./
    * readFileSync, es bloqueante, espera a terminarla, la q no tiene sync sigue con la ejecucion
CLASE 05:
    * npm init en consola para crear el package-json, donde instalar todas las librerias necesarias
    * npm install solo te instala en dependencias generales, si le pones npm install --save--dev {nombre de la libreria} o npm install -D te la instala en dev dependencies
    * cors libreria, nos permite aceptar request en el server desde cualquier punto del planeta, aunque sea raro
    * en el package-json si tenemos antes de la version de la libreria un:
        1) ~ significa q cuando cuando hagamos npm install solo se actualizara a las veriones con un cambio de patch example: '1.13.14', en este caso el 14
        2) ^ significa q actualiza los patch y los cambios menores, example: 1.13.14 ---> actualizaria en el .13 y .14
        3) * significa q actualiza todoo, los patchs, los minor releases o major releases
        4) si no hay ninguna de las 3 de arriba, se acepta solo la version puesta
    * para correr el archivo vamos a la parte de scripts en package-json y ponemos "start": "node index.js" ---> luego en consola se corre con node start
VER CORS EN MOZILLA: https://developer.mozilla.org/es/docs/Web/HTTP/CORS
CLASE 06:
    * http: hiper text transfer protocol
    * el modulo http:
        es nativo
        trabaja con el protocolo HTTP
        para usarlo require('http')
        para crear un servidor hacemos: http.createServer()
        para linkear un puerto al codigo hhtp.server.listen(3000, ()=> {}), asi ? ver bien
    * payload ---> informacion q se reciba o se envie en una API
    * para hacer import .... from ... en vez de const ... = require('...') tenemos q ir al package.json y ponerle antes de los script "type": "module",
    * la diferencia entre res.send() y res.end() es q res.end() da como finalizada la ejecucion, osea ya no hace mas nada. Ademas no pueden enviar todos los tipos de datos. Tambien existe el res.render() q manda un html a renderizar
    * para iniciar con exprees en ves de html (ademas hay q instalarlo, pq no es un modulo nativo):
        1) let express = require('express'); o import express from 'express'
        2) let app = express()
    * exiten dos tipos de API ---> tipo rest, q trabaja con endpoints, y graphQl que es un solo endpoint q devuelve una red con todo
    * https://glitch.com/ sirve para deployar un servidor rudimentario
CLASE 07:
    * una api restful tiene q usar base de datos o archivos para q sea persistente pq se debe resetear todo al recargar
    * status code:
        1xx ---> informativos
        2xx ---> exito
        3xx ---> redireccion
        4xx ---> cliente error
        5xx ---> server error
    * swagger es una pagina para documentar y hacer peticiones
    * rest indica ademas los formatos de transferencia de archivos. Los mas comunes. XML y JSON
    * API REST:
        1) no tiene interfaz grafica
        2) utiliza protocolo http
        3) arquitectura cliente servidor: cada mensaje http contiene toda la info necesaria para hacer la peticion. Esto hace que cliente y servidor esten debilmente acoplados (importante)
        4) cacheable: para almacenar informacion en una memoria y asi no tenes q consultar todo el tiempo. Esto hace q sea mas performante
        5) operaciones comunes (operaciones crud)
        6) interfaz uniforme
        7) utilizacion de hipermedios
    * una app de chatting no se hace con api rest. Se hace con otra api de comunicacion en tiempo real, q se hacen con otro protocolo. Usan socket io.
    * capas en arquitectura de api restful: routing, capa de negocios, orm (capa de conexion con la base de datos)
    * para pasar parametros por la url tenes params, y query params:
        query params: empiezan en el momento en el q la url tiene '?' y siguen con "clave=valor", si se quieren agregar mas ponemos un "&"
        params: se les pasa desp de un "/:params"
    * lazy loading, sirve para la paginacion.
    * para q el server con express pueda interpretar de forma automaticva los mensajes de tipo JSON en formato urlencoded al recibirlos, debemos agregarle lo siguiente al crearlo:
        1) app.use(express.json())
        2) app.use(express.urlencoded({extended: true}))
    * para aplicar un middleware a nivel de aplicacion ponemos app.use()
CLASE 08:
    * para el manejo de rutas express tiene una clase llamada Router. Sirve para modularizar la api rest
    * para usarlo ponemos --->
    const express = require('express')
    const { Router } = express
    const app = express()
    const router = Router()
    * las clases siempre se llaman con mayusculas
    * los middleware tienen el parametro next, donde lo usamos poniendo next() y hace q se ejecute siemrpe la siguiente funcion en la lista
    *middlewares tipos:
        ** a nivel de aplicacion
        ** a nivel de router
        ** manejo de errores
        ** incorporados
        ** de terceros
    * module exports para exportar en el back siempre
    * cuando usas import es pq te queres traer todo sino en require para traerte solo una cosa

CLASE 09:
    * handlebars es un lenguaje de plantillas
    * tienen un template, una data base y con eso genera un template

clase 10:
    * pug y ej son motores de templates como handlebars
    * pug esta diseñado para hacer cosas mas pequeñas. Funciona como python mediante tabs e identaciones. Se le pasan las vistas y el motor para setearlo
    * la extension del template es .pug
    * en el endpoint ponemos res.render('la vista', {un objeto con los datos q necesita el template para pintarlo})
    * seteo:
        app.set('views', './views'); el segundo parametro es el path raiz donde estan los archivos de las vistas
        app.set('view engine', 'pug');
    * para las props en pug se hace div() y entre los parentesis le pones lo q le queres dar
    * la etiqueta meter de html es una barra con min max y value para mostrrar
    * ejs es un motor de plantillas ---> npm install ejs
    *para seteo:
        app.set('view engine', 'ejs')
        el res.render busca dentro de la carpeta views. Osea q esto lo hace por defecto
    * sintaxis:
        <%= incrusta en plantilla el valor tal cual esta
        <%- incrusta en la plantilla el valor renderizado como html
        <% admite js
    * poniendo <%- inclue('./partials/header.ejs')-%> incluimos los partials q son como las partes q podemos reutilizar en los templates
Clase 11:
    * Websocket es un protocolo de red basado en TCP que establece cómo deben intercambiarse datos entre redes.
    * Es un protocolo fiable y eficiente, utilizado por prácticamente todos los clientes.
    * El protocolo TCP establece conexiones entre dos puntos finales de comunicación, llamados sockets.
    * De esta manera, el intercambio de datos puede producirse en las dos direcciones
    * websockets tiene conexiones bidireccionales, tenes acceso a los datos de forma rapida y permite una comunicacion directa y en tiempo real
    * handshake ?? (es la conexion)
    * Para iniciar el intercambio con Websocket el cliente envía una solicitud, al igual que en el clásico HTTP. Sin embargo, la conexión se establece mediante TCP y permanece abierta tras el handshake entre el cliente y el servidor.
    * El nuevo esquema URL de Websocket para las páginas web mostradas se define con el prefijo ws en lugar de http. El prefijo que corresponde a una conexión segura es wss, de forma análoga a https.
    * web sockets es un protocolo de comunicacion
    * Socket.IO es una biblioteca de JavaScript para aplicaciones web en tiempo real. Permite la comunicación bidireccional en tiempo real entre servidores y clientes web.
    * Tiene dos partes:
        - Una biblioteca del lado del cliente que se ejecuta en el navegador.
        - Una biblioteca del lado del servidor para Node.js.
    * Ambos componentes tienen una API casi idéntica. Al igual que Node.js, está impulsado por eventos.
    * caracteristicas de socket.io:
        - Fiabilidad: Las conexiones se establecen incluso en presencia de:
            proxies y balanceadores de carga.
            firewall personal y software antivirus.
        - Soporte de reconexión automática: A menos que se le indique lo contrario, un cliente desconectado intentará siempre volver a conectarse, hasta que el servidor vuelva a estar disponible.
        - Detección de desconexión: Se implementa un mecanismo de heartbeat, lo que permite que tanto el servidor como el cliente sepan cuando el otro ya no responde.
        - Soporte binario:  Se puede emitir cualquier estructura de datos serializable, que incluye:
            - ArrayBuffer y Blob en el navegador
            - ArrayBuffer y Buffer en Node.js
    * Utilizando el método io.sockets.emit enviamos un mensaje global a todos los clientes conectados al canal de Websocket
Clase 12:
    * io.on('connection', function(socket) {
        console.log('Un cliente se ha conectado');
        });
    * io.on('connection'. funcion) indica cuando alguien se conecta al servidor
    * con io.sockets.emit, que notificará a todos los sockets conectados.
    * emit el primer parametro es el nombr del evento
    * socket esta basado en eventos, entre on y emit (on recibe, emit envia)
Clase 13:
    * Un transpilador es un tipo especial de compilador que traduce de un lenguaje fuente a otro fuente. Se diferencia de los compiladores tradicionales ya que estos últimos reciben como entrada archivos conteniendo código fuente y generan código máquina del más bajo nivel.
    * La diferencia radica en la relación entre los lenguajes origen y destino de la traducción. El transpilador traduce código entre dos lenguajes que están al mismo nivel de abstracción, mientras que el compilador lo hace entre lenguajes de diferente nivel de abstracción
    * babel es un transpilador
    * Babel es un transpilador que nos permite transformar nuestro código JS de última generación (o con funcionalidades extras) a JS que cualquier navegador o versión de Node.js entienda.
    * Babel funciona mediante plugins con los cuales le indicamos cuál es la transformación que vamos a efectuar.
    * El código escrito en origen.js pertenece a ES6 ya que usa const y las nuevas arrow functions y queremos que Babel lo convierta a JS5. Para ello, definimos un script en el package.json:
        ----> "build": "babel ./origen.js -o ./destino.js -w" La opción -w nos permite transpilar automáticamente ante los cambios en origen.js
    * Los archivos de TypeScript se compilan en JavaScript mediante TSC: el compilador de TypeScript. TSC se puede instalar como paquete TypeScript a través de npm
    * Conversion mediante transpilador de typescript a js:
        1- Creamos un proyecto de Node.js con npm init -y
        2- Instalamos el TSC mediante npm: npm i typescript
        3- Creamos un archivo index.ts con contenido en Typescript
        4- Transpilamos con el comando: node_modules/.bin/tsc ./index.ts -w
        5- Verificamos que en nuestra carpeta de proyecto se encuentre index.js
    * A partir de ES6 de Node.js admite definir archivos y proyectos como módulos. A diferencia de los archivos y proyectos comunes en JavaScript (“commonJs”), los módulos permiten ser importados en forma asincrónica en lugar de sincrónica, lo cual libera el hilo principal y mejora la performance de los programas (entre otras ventajas). Cuando se trata de proyectos, este cambio se puede realizar fácilmente desde el archivo package.json, agregando el siguiente par clave-valor: "type": "module".
    * ARCHIVO TSCONFIG ---> TypeScript utiliza un archivo llamado tsconfig.json para configurar las opciones del compilador para un proyecto. Para crear el archivo tsconfig.json ejecutamos el siguiente comando:  ./node_modules/.bin/tsc --init. Este comando generará un archivo tsconfig.json bien redactado.
    * Algunas de las claves más importantes de tsconfig.json
        - module: Especifica el método de generación de código del módulo.
        - target: Especifica el nivel de lenguaje de salida.
        - rootDir: Especifica el directorio raíz de los archivos de entrada. Se usa sólo para controlar la estructura del - directorio de salida con outDir.
        - outDir: Esta es la ubicación para los archivos .js tras la transpilación.
    * Mediante los scripts creados en package.json ponemos en acción los mecanismos de transpilación manual y automática junto con la puesta en marcha del proyecto.
        - "build": "tsc" -> transpilación manual.
        - "watch": "tsc -w"-> transpilación automática.
        - "start": "node ./dist/index.js" -> ejecución de código transpilado.
    * cuando usamos import en vez de require estamos usando asincronismo, eso hace q no bloquee el hilo de ejecucion. Con el require lo importa sincronicamente
Clase 14:
    * Webpack es un empaquetador de módulos (module bundler), que genera un archivo único con todos los módulos que necesita la aplicación para funcionar. Permite encapsular todos los archivos JavaScript en un único archivo, por ejemplo bundle.js
    * npm install webpack webpack-cli para instalar webpack
    * "scripts": {
            "build": "webpack ./rutaDelArchivoQueQueresEmpaquetar"
        }, ----> esto genera una carpeta dist con el archivo main.js empaquetado
    * En caso de no especificar, buscará un archivo index.js dentro de una carpeta src por defecto, e incluirá en forma recursiva todas las dependencias de ese archivo y de sus dependencias.
    * El modo modo desarrollo o producción define si el código generado tendrá formato de lectura amigable y comentarios, o si estará minificado, respectivamente. Ejemplo scripts dentro del package.json:
        - "build": "webpack ./a1.js ./a2.js ./a3.js --mode=production",
        - "dev": "webpack ./a1.js ./a2.js ./a3.js -w --mode=development",
    * creacion del proyecto de nodejs con typescript y webpack. Pasos:
        - Generamos la carpeta de proyecto
        - Inicializamos un proyecto de node con npm init -y
        - Dentro del proyecto creamos un carpeta src con un archivo index.ts.
        - Instalamos las dependencias de desarrollo:
        - npm i -D typescript ts-loader webpack webpack-cli webpack-node-externals
        - Instalamos las dependencias del proyecto:
        - npm i express @types/express
        - Creamos el archivo tsconfig.json (configuración del transpilador typescript) con el comando ./node_modules/.bin/tsc --init
        - Modificamos tsconfig.json dejando la clave "noImplicitAny" en false (deshabilita la generación de errores en expresiones y declaraciones con cualquier tipo implícito)
        - Creamos el archivo webpack.config.js y le agregamos el siguiente contenido:
            const path = require('path');
            const nodeExternals = require('webpack-node-externals');

            module.exports = {
            mode: 'production',
            entry: './src/index.ts',
            target: "node",
            externals: [nodeExternals()],

            output: {
                path: path.resolve(__dirname, 'dist'),
                filename: 'main.js',
            },
            resolve: {
                extensions: ['.ts', '.js'],
            },
            module: {
                rules: [
                    {
                        test: /\.tsx?/,
                        use: 'ts-loader',
                        exclude: /node_modules/
                    }
                ]
            }
        }
        * en el package.json agregamos lo siguiente:
            -  "main": "dist/main.js",
            - "scripts": {
                "build": "webpack",
            },
    * Propiedades que podemos configurar:
        - mode: para el modo de trabajo (development ó production)
        - entry: para definir el punto de entrada de nuestro código.
        - externals: permite el correcto funcionamiento con algunas librerías externas (en este caso, express)
        - output: para definir el punto de salida.
        - resolve: configura cómo se resuelven los módulos
        - module: sirve para aclararle a Webpack cómo debe procesar los loaders que queramos usar para un proyecto.
    * Los loaders son transformaciones que se aplican en el código fuente de nuestras aplicaciones. Existen decenas de ellos, para usar cantidad de tecnologías y transformar código de preprocesadores, código HTML, Javascript, etc. Son como una especie de tareas que Webpack se encargará de realizar sobre nuestro código, cada una especializada en algo en concreto. ts-loader es un TypeScript loader para webpack. Mediante las rules definidas dentro de la entrada module, podemos establecer a qué archivos se aplican los loaders que sean necesarios.
Clase 15:
    * importante: poner ; en los comandos q ingreso por la consola
    * La sigla que se conoce como SQL corresponde a la expresión inglesa Structured Query   Language (en español “Lenguaje de Consulta Estructurado”)
    * SQL es un tipo de lenguaje vinculado con la gestión de bases de datos de carácter relacional, que permite la especificación de distintas clases de operaciones entre éstas.
    * Gracias a la utilización del álgebra y de cálculos relacionales, el SQL brinda la posibilidad de realizar consultas con el objetivo de recuperar información de las bases de datos de manera sencilla
    * MySQL es un sistema de gestión de bases de datos relacional desarrollado bajo licencia dual: Licencia pública general/Licencia comercial por Oracle Corporation y está considerada como la base de datos de código abierto más popular del mundo.
    * MariaDB es un sistema de gestión de bases de datos derivado de MySQL con licencia GPL (General Public License).
    * MySQL y MariaDB son compatibles entre sí a nivel funcional.
    * SQL es un LENGUAJE
    * MySQL es un gestor de base de datos relacionales
    * XAMPP es un paquete de software libre, que consiste principalmente en el sistema de gestión de bases de datos MySQL
    * PASOS PARA USARLO:
        1) abrimos XAMPP y le damos a start en el de MySQL
        2) apretamos el boton de shell y en consola ponemos myqsl -u root
        3) ahi se deberia poder usar ya y sino buscamos https://onecompiler.com/mysql
    * CREACION DE TABLA:
        CREATE TABLE NombreQueQueremosPonerle (
            id INTEGER PRIMARY KEY AUTO_INCREMENT,
            nombre TEXT(255) NOT NULL,
            apellido TEXT(255) NOT NULL,
            email TEXT(255) NOT NULL,
            edad numeric NOT NULL
        )
        PRIMARY KEY significa q es unica y q con ese campo vamos a hacer las relacionales
        AUTO_INCREMENT quiere decir q sola se va incrementando
        NOT NULL para q no sea nullo
        INTEGER se le dice de q tipo de dato es, en este caso entero
        varchar(255) significa q es de tipo string y q tiene maximo 255 caracteres
    * CREATE, INSERTAR DATOS A LA TABLA:
        INSERT INTO <nombre de la tabla>(<nombre de las props q queremos insertar, ej: 'nombre'>) VALUES(<valores de los campos q pusimos antes, se asignar en orden de nombramiento, ej: 'nicolas'>)
    * UPDATEAR
        UPDATE nombreTabla
        SET colum1 = value1, colum2 = value2, ...
        WHERE condition

        SET es para decir q valores voy cambiando, par clave valor. Aca si poenmos ej: edad = 20. Directamente se los cambia a todos
        WHERE sirve para condicionar. Es opcional
    * LEER
        SELECT * from nombreDeLaTabla
    * DELETE
        ** por lo general cuenta con una condicion (WHERE)
        delete from nombretabla ----> elimina todo de la tabla
    * COMANDOS
        * show tables ----> te muestra las tablas
        * describe table <nombredelatabla> ----> te muestra algunos datos de la tabla
        * select * from nombreDeLaTabla ---> te muestra toda la tabla con los datos
    * MODIFICAR LA ESTRUCTURA DE LA TABLA. OSEA LA CABECERA:
        * ALTER TABLE nombre_table ADD column_name datatype(ejjemplo TEXT);
    * ELIMINAR UNA TABLA
        * drop table nombre_tabla;
    * es importante poner ; al final de cada sentencia
CLASE 16:
    * Knex.js es un generador de consultas SQL con "baterías incluidas" para Postgres, MSSQL, MySQL, MariaDB, SQLite3, Oracle y Amazon Redshift, diseñado para ser flexible, portátil y fácil de usar.
    *Cuenta con una interfaz basada en callbacks y en promesas.
    *Knex se puede utilizar como un generador de consultas SQL en Node.JS.
    *Se puede instalar desde npm con el comando npm i knex
    *Además debemos instalar las dependencias de las base de datos con la cual vamos a trabajar: npm i -> pg para PostgreSQL y Amazon Redshift, mysql para MySQL y MariaDB, sqlite3 para SQLite3 ó mssql para MSSQL.
    * inicialización del proyecto e instalación de dependencias:
        - Creamos un proyecto Node.js con npm init -y
        - Instalamos la dependencias Knex y mysql con npm i knex mysql (mysql es el plugin necesario para trabajar con MariaDB)
        - Levantamos el motor de base de datos MariaDB con XAMPP.
        - Creamos los archivos necesarios para probar los comandos SQL necesarios en acciones CRUD.
    * un ORM abstrae la base de datos para q el programador haga consultas en el lenguaje que esta programando sin necesitar usar el lenguaje SQL. Mapea la data q viene de la base de datos para que la podamos usar facilmente en codigo
    * El mejor ORM para typescript o javascript es: TypeORM
    * para instalar knex hacemos:
        1) npm install knex --save y npm install y la base de datos q usemos (mysql, pg, etc)(ver documentacion oficial knex)
        2) para conectarlo hacemos:
            const knex = require('knex')({
                client: 'mysql',
                connection: {
                    host: '127.0.0.1',
                    port: 3306,  <puerto por defecto para las bases de datos>
                    user: 'mi_usuario_database',  <nombre de usuarios q tenemos en la base de datos creada>
                    password: 'mi_contraseña_database',  <password q tenemos en la base de datos creada>
                    database: 'my_app_test'  <nombre q le dimos al a base de datos>
                }
            })
            OBS: podemos ver la docu oficial de knex q lo explica
    * los seeds nos permiten meterle info a la base de datos en su primera carga, tambien sirve como mock para probar
    * tambien poseen migraciones. Que te permite volver atras si hiciste algo mal(rollback)
    * los orm tienen mecanismo para proteger las bases de datos
    * knex cheetsheets ---> https://devhints.io/knex
    * PARA DARLE UN NOMBRE A LA BASE DE DATOS PONEMOS:
        create database NOMBREQLEPONEMOS;
        use NOMBREQLEPUSIMOS;
    * SQLITE es una libreria en lenguaje C, es un motor de bases de datos como mysql. Es multiplataforma, su principal virtud. Es de dominio publico y lo tienen casi todos los dispositivos ya instalados



